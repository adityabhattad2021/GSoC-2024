<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>Google Summer of Code 2024</title>
            <style>

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only],
.vscode-high-contrast:not(.vscode-high-contrast-light) img[src$=\#gh-light-mode-only],
.vscode-high-contrast-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
            <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <h1 id="google-summer-of-code-2024">Google Summer of Code 2024</h1>
<h3 id="project-proposal---agora-blockchain">Project Proposal - Agora Blockchain</h3>
<h3 id="personal-details">Personal Details</h3>
<p>Name: Aditya Bhattad</p>
<p>Email: <a href="mailto:adityabhattad18@gmail.com">adityabhattad18@gmail.com</a></p>
<p>College Name: <a href="http://www.rknec.edu/">Shri Ramdeobaba College of Engineering and Management</a></p>
<p>Degree: Bachelor of Technology in Computer Science and Engineering</p>
<p>Expected Graduation Year: 2025</p>
<h1 id="chosen-idea-agora-blockchain">Chosen Idea: Agora Blockchain</h1>
<h2 id="1introduction">1.Introduction</h2>
<p><strong>1.1 Project Overview</strong></p>
<p>The Agora Blockchain DApp is a decentralized voting application that enables secure, transparent and anonymous voting processes using zero knowledge proofs and blockchain. It offers features such as user registration, election creation, voting, result calculation, user KYC using Polygon ID, and an anonymous voting flow using the Semaphore library.</p>
<p><strong>1.2 Current State of Agora Blockchain DApp</strong></p>
<p>While the Agora Blockchain DApp provides a solid foundation for conducting elections on the blockchain, there are several areas that can be enhanced to improve user experience, accessibility, and overall functionality. The current implementation lacks sufficient abstraction of blockchain complexities for non-technical users, and the codebase requires refactoring and organization to facilitate easier development and maintenance.</p>
<p><strong>1.3 Proposed Enhancements</strong></p>
<p>This proposal aims to enhance the current Election DApp by adding new features and refactoring existing ones.
Here is a summary of the proposed improvements:</p>
<ol>
<li><strong>Abstraction of Blockchain</strong>: The goal is to partially abstract the blockchain part from the election administrator and fully abstract it from the voter. This will allow users to enjoy the benefits of blockchain technology, such as immutability, without having to worry about their wallet address or blockchain transactions. The user experience will be native and completely anonymous and secure.</li>
<li><strong>Election Subscription</strong>: Allow voters to subscribe to election results and receive notifications when elections conclude, keeping them engaged and informed.</li>
<li><strong>Code Refactoring</strong>: Rewrite the Client Side Code in <code>Nextjs</code>/ <code>Typescript</code> and Organize the Codebase: The current repository is divided into several different folders, such as client, server, <code>clientAnonymous</code>, and <code>serverAnonymous</code>. Some libraries used in the client, like <code>rimble-ui</code>, <code>libsemaphore</code>, and <code>react16</code>, are long deprecated and not actively maintained anymore. This leads to a poor developer experience and slows down development due to conflicts. Rewriting the client and organizing the codebase properly can solve these issues.</li>
<li><strong>Connect Anonymous Voting to Multiple Voting Algorithms and Extensively Test Smart Contracts</strong>: Currently, anonymous voting only supports normal general election types. It needs to be integrated with other smart contracts that have implemented multiple election algorithms using the Diamond Multi-Facet Proxy. To gain the trust of users and avoid bugs during usage, an extensive test suite that tests every aspect of the smart contract is required. This will make the smart contract much more reliable.</li>
<li><strong>Add More Election Types</strong>: There is still room to add more election types, such as approval voting and quadratic voting, to give users more choices.</li>
</ol>
<p>By implementing these enhancements, the Election D-App will become more user-friendly, secure, and accessible to a wider audience. The proposed changes will significantly improve the user experience, increase trust in the platform, and contribute to the overall adoption of the project.</p>
<h2 id="detailed-proposal-description">Detailed Proposal Description</h2>
<h2 id="1-abstraction-of-blockchain">1. Abstraction of Blockchain</h2>
<ul>
<li>
<p><strong>1.1 Motivation and Goals</strong></p>
<p>In 2024, abstraction plays a crucial role in the adoption of blockchain-powered applications. Users should be able to benefit from immutability and security without needing to understand the underlying blockchain technology.</p>
<p>The goals of this part of the project are:</p>
<ol>
<li>Allow general users to register and vote without interacting with blockchain wallets</li>
<li>Partially abstract blockchain details for election admins while still giving them control</li>
<li>Provide a seamless, web2-like user experience while leveraging web3 benefits under the hood</li>
</ol>
</li>
<li>
<p><strong>1.2 User Flows</strong></p>
<ul>
<li>
<p><strong>1.2.1 Onboarding Flow for General Users</strong></p>
<ol>
<li>
<p>User registers to the application using a standard web2 flow like sign in with Google or email. User details are saved to the backend.</p>
</li>
<li>
<p>Backend generates a random passphrase string and maps it to the user account. This will later be used to create the identity commitment for the user.</p>
</li>
<li>
<p>User is acknowledged and redirected to the general dashboard of the voting application.</p>
<p><img src="file:////workspaces/GSoC-2024/assets/user_registration.png" alt="user registration.png"></p>
</li>
</ol>
</li>
<li>
<p><strong>1.2.2 Election Admin Flow</strong></p>
<ol>
<li>Registered users can choose to create an election. When they click on create election button, they are prompted to connect their web3 wallet in order make a smart contract call to create election on blockchain, which is necessary for the election admin to have independent control, making our application truly decentralized.
To make our application more accessible we can enable functionality that will allow the user to create wallet on fly using their connected email addresses.</li>
<li>Once the wallet is connected and linked to their account, the election admin will:
<ol>
<li>Choose the election type</li>
<li>Add the election title and description</li>
<li>Add candidates</li>
<li>Set the start time and duration for the election</li>
<li>And click submit</li>
</ol>
</li>
<li>Election details are sent to the entry point smart contract, from where a new proxy contract is deployed which will be linked to the logic contracts (Ballot and Result Calculators) of the selected algorithm.</li>
<li>Upon successful blockchain transaction, backend is updated with election details metadata and admin is redirected to admin dashboard from where they can manage the election and approve voters.</li>
</ol>
<p><img src="file:////workspaces/GSoC-2024/assets/election_admin_flow.png" alt="election admin flow.png"></p>
</li>
<li>
<p><strong>1.2.3 Voter Flow</strong></p>
<ol>
<li>Onboarded users can browse and search available elections.</li>
<li>To vote in the particular election, users first have to submit application for approval from the admin on their election page.</li>
<li>Users wait for approval from the election admin.</li>
<li>When an admin approves the user, their email address along with a secret key on the backend, is used to generate an Identity Commitment, which will be stored on the smart contract of the election they have been approved for.</li>
<li>Voters are notified via email once approved.</li>
<li>After approval, when the voting period starts, the user can submit their vote:
<ol>
<li>When user clicks on vote, their Identity Commitment is again generated on the backend using their email and secret key, which then fetched to the client to generate ZK proofs.</li>
<li>Using the users identity commitment and the election Id the ZK proofs are generated on the client.</li>
<li>Proofs are submitted to backend which works as a re-layer in this case, from here the proofs are submitted to the blockchain in a transaction.</li>
<li>Blockchain verifies the ZK proofs to confirm the user is an approved voter who hasn't yet voted. If valid, their vote is registered.</li>
</ol>
</li>
<li>Users can subscribe to an election to be notified of the results via email once it concludes.</li>
</ol>
<p><img src="file:////workspaces/GSoC-2024/assets/voter_flow.png" alt="voter flow.png"></p>
</li>
</ul>
</li>
<li>
<p>1.3 Technical Implementation</p>
<p>Assuming we are rewriting the client in Next.js, here is an overview of the technical implementation:</p>
<ul>
<li>
<p>Use Next.js to create user interfaces for registration, election creation/management, and voting.</p>
</li>
<li>
<p>Integrate Web3Modal library for seamless web3 wallet connection and on-the-fly wallet creation for election admins.</p>
</li>
<li>
<p>Use Next.js API routes to handle backend logic like user registration, identity commitment generation and working as a middle layer to send the ZK Proofs to the blockchain.</p>
</li>
<li>
<p>Utilize Semaphore SDK to develop anonymous voting flow</p>
</li>
<li>
<p>Use Supabase PostgreSQL to store user info and election metadata.</p>
</li>
<li>
<p>Utilize NextAuth to handle user authentication in the application.</p>
</li>
<li>
<p>1.3.1 Architecture</p>
<p><img src="file:////workspaces/GSoC-2024/assets/System_Architecture_Diagram.png" alt="System Architecture Diagram.png"></p>
</li>
<li>
<p>1.3.2 Frontend Implementation in Next.js/TypeScript</p>
<ul>
<li>
<p>1.3.2.1 Screens</p>
<p>Frontend will have the following screens</p>
<ul>
<li>
<p><strong>Agora Blockchain Landing Page (Not protected)</strong>: This page can be used to explain how the entire anonymous flow works, and a brief overview about all the available algorithms, this will help the election organizer to make an informed choice while election algorithm selection.</p>
</li>
<li>
<p><strong>Login/Registration Page (Not protected)</strong>: We can conditionally render login and register input fields and an separate option to sign in with google.</p>
</li>
<li>
<p><strong>General Dashboard (Not protected)</strong>: This page will contains stats about all the election like created, on going, concluded, etc. and list of all the elections in table along with a search bar to search for the relevant election.</p>
</li>
<li>
<p><strong>Election Creation Modal (Protected)</strong>: The modal will contain input field for election title, election description, election type, and start date and duration of the election.</p>
</li>
<li>
<p><strong>Election Admin dashboard (Protected)</strong>: This will contain list of all the elections created by the users, list of all the voters applied for the election, a button to add candidates for the election, and a button to conclude the election.</p>
<p><img src="file:////workspaces/GSoC-2024/assets/Agora_Blockchain_Election_Dashboard.png" alt="Agora Blockchain Election Dashboard.png"></p>
</li>
<li>
<p><strong>Add candidate Modal (Protected)</strong>: This will contain input fields for name, description and image of the candidate.</p>
</li>
<li>
<p><strong>Election Page (Protected)</strong>: This page will contain the election details like start time, end time, number of voters registered for the election, candidates contesting in the elections, etc.</p>
</li>
<li>
<p><strong>Vote Modal (Protected)</strong>: This will contain input field to choose candidate from the all the candidates to vote in the elections, we will have to conditionally render multiple types of UIs here based on the election algorithm.</p>
</li>
</ul>
</li>
<li>
<p>1.3.2.2 User Authentication with NextAuth.js (Backend side of the logic is discussed separately).</p>
<ol>
<li>
<p>After setting up the NextAuth.Js on backend we will have to implement a middleware that will block the access to the protected pages of our application.</p>
<p>This can be implemented by adding <code>middleware.ts</code> file in the root of our NextJs Application.</p>
<pre><code class="language-tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">NextAuth</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;next-auth&quot;</span>;
<span class="hljs-keyword">import</span> authConfig <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./auth.config&quot;</span>;  <span class="hljs-comment">// this will be covered in the backend part.</span>
<span class="hljs-keyword">import</span> { <span class="hljs-variable constant_">DEFAULT_LOGIN_REDIRECT</span>, publicRoutes } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./routes&quot;</span>;

<span class="hljs-keyword">const</span> { auth } = <span class="hljs-title class_">NextAuth</span>(authConfig);

<span class="hljs-keyword">const</span> apiAuthPrefix = <span class="hljs-string">&quot;/api/auth&quot;</span>;

<span class="hljs-keyword">const</span> publicRoutes = [
    <span class="hljs-string">&quot;/&quot;</span>,
    <span class="hljs-string">&quot;/auth/verify-email&quot;</span>,
];

<span class="hljs-keyword">const</span> authRoutes = [
    <span class="hljs-string">&quot;/auth/login&quot;</span>,
    <span class="hljs-string">&quot;/auth/register&quot;</span>,
    <span class="hljs-string">&quot;/auth/error&quot;</span>,
];

<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">DEFAULT_LOGIN_REDIRECT</span> = <span class="hljs-string">&quot;/dashboard&quot;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">auth</span>(<span class="hljs-function">(<span class="hljs-params">req</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> { nextUrl } = req;
    <span class="hljs-keyword">const</span> isLoggedIn = !!req.<span class="hljs-property">auth</span>;

    <span class="hljs-keyword">const</span> isApiAuthRoute = nextUrl.<span class="hljs-property">pathname</span>.<span class="hljs-title function_">startsWith</span>(apiAuthPrefix);
    <span class="hljs-keyword">const</span> isPublicRoute = publicRoutes.<span class="hljs-title function_">includes</span>(nextUrl.<span class="hljs-property">pathname</span>);
    <span class="hljs-keyword">const</span> isAuthRoute = authRoutes.<span class="hljs-title function_">includes</span>(nextUrl.<span class="hljs-property">pathname</span>);

    <span class="hljs-keyword">if</span> (isApiAuthRoute) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">if</span> (isAuthRoute) {
        <span class="hljs-keyword">if</span> (isLoggedIn) {
            <span class="hljs-keyword">return</span> <span class="hljs-title class_">Response</span>.<span class="hljs-title function_">redirect</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-variable constant_">DEFAULT_LOGIN_REDIRECT</span>, nextUrl));
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">if</span> (!isLoggedIn &amp;&amp; !isPublicRoute) {
        <span class="hljs-keyword">let</span> callBackUrl = nextUrl.<span class="hljs-property">pathname</span>;
        <span class="hljs-keyword">if</span> (nextUrl.<span class="hljs-property">search</span>) {
            callBackUrl += nextUrl.<span class="hljs-property">search</span>;
        }

        <span class="hljs-keyword">const</span> encodedCallbackUrl = <span class="hljs-built_in">encodeURIComponent</span>(callBackUrl);
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Response</span>.<span class="hljs-title function_">redirect</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">`/auth/login?callbackUrl=<span class="hljs-subst">${encodedCallbackUrl}</span>`</span>, nextUrl));
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
})

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> config = {
    <span class="hljs-attr">matcher</span>: [<span class="hljs-string">&quot;/((?!api|_next/static|_next/image|favicon.ico).*)&quot;</span>],
}
</code></pre>
</li>
<li>
<p>To be able use/display users information throughout the client, we will need to use theÂ <code>useSession</code>Â hook, first we have to expose the session context,Â <strong><code>&lt;SessionProvider /&gt;</code></strong>, at the top level of our application:</p>
<pre><code class="language-tsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">RootLayout</span>(<span class="hljs-params">{
  children,
}: Readonly&lt;{
  children: React.ReactNode;
}&gt;</span>) {
  <span class="hljs-keyword">const</span> session = <span class="hljs-keyword">await</span> <span class="hljs-title function_">auth</span>();
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">SessionProvider</span> <span class="hljs-attr">session</span>=<span class="hljs-string">{session}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{inter.className}</span>&gt;</span>{children}<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">SessionProvider</span>&gt;</span></span>
  );
}
</code></pre>
</li>
<li>
<p>Then we can use the user information in any component like:</p>
<pre><code class="language-tsx"><span class="hljs-keyword">import</span> { useSession } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;next-auth/react&quot;</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Component</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> { <span class="hljs-attr">data</span>: session } = <span class="hljs-title function_">useSession</span>()
    <span class="hljs-keyword">return</span> (
      <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span>
        Signed in as {session.user.email}
      <span class="hljs-tag">&lt;/&gt;</span></span>
  }
}
</code></pre>
</li>
</ol>
</li>
<li>
<p>1.3.2.3: Add functionality to connect wallet for the election organizer: To streamline the development of the connect wallet flow and make wallet connection experience smoother by adding functionality to generate a wallet on fly using email address, we can use walletconnectâ€™s <code>web3modal</code> .</p>
<p>To set it up we have to:</p>
<ol>
<li>
<p>Create a new file <code>context/web3modal.tsx</code> outside the app directory, this file will include all the configuration required for web3 modal.</p>
<pre><code class="language-tsx"><span class="hljs-string">&#x27;use client&#x27;</span>

<span class="hljs-keyword">import</span> { createWeb3Modal, defaultConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@web3modal/ethers5/react&#x27;</span>

<span class="hljs-keyword">const</span> projectId = process.<span class="hljs-property">env</span>.<span class="hljs-property">WALLET_CONNECT_PROJECT_ID</span>

<span class="hljs-comment">// example chain</span>
<span class="hljs-keyword">const</span> mainnet = {
  <span class="hljs-attr">chainId</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Ethereum&#x27;</span>,
  <span class="hljs-attr">currency</span>: <span class="hljs-string">&#x27;ETH&#x27;</span>,
  <span class="hljs-attr">explorerUrl</span>: <span class="hljs-string">&#x27;https://etherscan.io&#x27;</span>,
  <span class="hljs-attr">rpcUrl</span>: <span class="hljs-string">&#x27;https://cloudflare-eth.com&#x27;</span>
}

<span class="hljs-comment">// 3. Create a metadata object</span>
<span class="hljs-keyword">const</span> metadata = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Agora Blockchain&#x27;</span>,
  <span class="hljs-attr">description</span>: <span class="hljs-string">&#x27;Agora is a blockchain-based voting system that allows for secure, anonymous, and transparent voting&#x27;</span>,
  <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;https://agorablockchain.com&#x27;</span>, <span class="hljs-comment">// origin must match your domain &amp; subdomain</span>
  <span class="hljs-attr">icons</span>: [<span class="hljs-string">&#x27;https://icon.agorablockchain.com/&#x27;</span>]
}

<span class="hljs-comment">// 4. Create Ethers config</span>
<span class="hljs-keyword">const</span> ethersConfig = <span class="hljs-title function_">defaultConfig</span>({
  metadata,
	<span class="hljs-attr">enableEmail</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// This well enable option to create wallet with email addresses</span>
})

<span class="hljs-comment">// 5. Create a Web3Modal instance</span>
<span class="hljs-title function_">createWeb3Modal</span>({
  ethersConfig,
  <span class="hljs-attr">chains</span>: [mainnet],
  projectId,
})

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Web3Modal</span>(<span class="hljs-params">{ children }</span>) {
  <span class="hljs-keyword">return</span> children
}
</code></pre>
</li>
<li>
<p>To make <code>useWeb3Modal</code> hook available in our entire application we will have to  expose thisÂ <strong><code>&lt;Web3Modal /&gt;</code></strong> context, at the top level of our application:</p>
<pre><code class="language-tsx"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./globals.css&#x27;</span>

<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Web3Modal</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../context/web3modal&#x27;</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> metadata = {
  <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Web3Modal&#x27;</span>,
  <span class="hljs-attr">description</span>: <span class="hljs-string">&#x27;Web3Modal Example&#x27;</span>
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">RootLayout</span>(<span class="hljs-params">{ children }</span>) {
  <span class="hljs-keyword">return</span> (
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">SessionProvider</span> <span class="hljs-attr">session</span>=<span class="hljs-string">{session}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{inter.className}</span>&gt;</span>
		       <span class="hljs-tag">&lt;<span class="hljs-name">Web3Modal</span>&gt;</span>{children}<span class="hljs-tag">&lt;/<span class="hljs-name">Web3Modal</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">SessionProvider</span>&gt;</span></span>
  )
}
</code></pre>
</li>
<li>
<p>Then we can simple use <code>useWeb3Modal</code> hook to trigger the wallet connection modal</p>
<pre><code class="language-tsx"><span class="hljs-keyword">import</span> { useWeb3Modal } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@web3modal/ethers/react&#x27;</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ConnectButton</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// 4. Use modal hook</span>
  <span class="hljs-keyword">const</span> { open } = <span class="hljs-title function_">useWeb3Modal</span>()

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> open()}&gt;ConnectWallet<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/&gt;</span></span>
  )
}
</code></pre>
<p>On clicking <code>Connect Wallet</code>, a modal like this will show up, allowing the user to connect their browser wallet or create a wallet with their emails.</p>
<p><img src="file:////workspaces/GSoC-2024/assets/Connect_Wallet.png" alt="Connect Wallet.png"></p>
</li>
</ol>
</li>
<li>
<p>1.3.2.4: Using semaphore SDK to generate zero knowledge proofs on the frontend:</p>
<p>What is Semaphore?</p>
<p><a href="https://github.com/semaphore-protocol/semaphore/tree/v3.15.2">Semaphore</a>Â is aÂ <a href="https://z.cash/technology/zksnarks">zero-knowledge</a>Â protocol that allows users to cast a signal (In user case a vote) as a provable group member (i.e. voter approved by the election admin) without revealing users identity. Additionally, it provides a simple mechanism to prevent double-signaling (casting vote more than ones).</p>
<p>It consists of three main parts</p>
<ul>
<li>
<p>Semaphore groups: A Semaphore group is anÂ <a href="https://docs.semaphore.pse.dev/V3/glossary#incremental-merkle-tree">incremental Merkle tree</a>, and group members are tree leaves. Semaphore groups set the following three parameters:</p>
<ul>
<li><strong>Group id</strong>: a unique identifier for the group</li>
<li><strong>Tree depth</strong>: the maximum number of members a group can contain (<code>max size = 2 ^ tree depth</code>)</li>
<li><strong>Members</strong>: the list of members to initialize the group.</li>
</ul>
</li>
<li>
<p>Semaphore identities: In order to join aÂ semaphore group, a user must first create aÂ semaphore identity.</p>
<p>Identity contains two random secret values:Â <code>trapdoor</code>Â andÂ <code>nullifier</code>, and one public value:Â <code>commitment</code>.</p>
  <aside>
  ðŸ’¡ Poseidon is a specialized hash function co-designed with zk-proof systems in mind, enabling practical hashing of field elements inside zk-friendly arithmetic circuits with attractive performance and security properties.
  </aside>
<p>The Poseidon hash of the identity nullifier and trapdoor is called theÂ <em>identity secret</em>, and its hash is theÂ <em>identity commitment</em>.</p>
<p>An identity commitment, similarly to Ethereum addresses, is a public value used in Semaphore groups to represent the identity of a group member. The secret values are similar to Ethereum private keys and are used to generate Semaphore zero-knowledge proofs and authenticate signals.</p>
</li>
<li>
<p>Semaphore proofs: Once a user joins theirÂ Semaphore identityÂ to aÂ Semaphore group, the user can signal anonymously with a zero-knowledge proof that proves the following:</p>
<ul>
<li>the user is a member of the group,</li>
<li>the same user created the signal and the proof.</li>
</ul>
</li>
</ul>
<p>We can use these three in combination to implement our anonymous voting flow:</p>
<ol>
<li>When the voter applies for the an election, and is approved by the admin an deterministic identity is created for the user using combination of their verified <code>email</code> and a <code>secret-key</code> stored on the backend.</li>
<li>The identity commitment (i.e. Public Value) is added to the on-chain group that corresponding to an particular election.</li>
<li>Then, when a approved user clicks on cast vote on the client:
<ul>
<li>
<p>The group corresponding to the election is fetched from the blockchain.</p>
<pre><code class="language-tsx"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Group</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@semaphore-protocol/group&quot;</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">SemaphoreEthers</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@semaphore-protocol/data&quot;</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">getGroupId</span>(<span class="hljs-params">electionId:number</span>):<span class="hljs-title class_">Group</span>{
		<span class="hljs-keyword">const</span> groupId = electionId
		<span class="hljs-keyword">const</span> semaphoreEthers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SemaphoreEthers</span>(process.<span class="hljs-property">env</span>.<span class="hljs-property">NEXT_PUBLIC_RPC_URL</span>)
		<span class="hljs-keyword">const</span> members = <span class="hljs-keyword">await</span> semaphoreEthers.<span class="hljs-title function_">getGroupMembers</span>(groupId)
		<span class="hljs-keyword">const</span> group = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Group</span>(groupId, members);
		<span class="hljs-keyword">return</span> group;
}
</code></pre>
</li>
<li>
<p>The identity is re-generated on the using the server actions and identity commitment is retrieved on the client.</p>
<pre><code class="language-tsx"><span class="hljs-comment">// Generate identity commitment using secret key and email</span>
<span class="hljs-string">&quot;use server&quot;</span>
<span class="hljs-keyword">import</span> crypto <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;crypto&#x27;</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Identity</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@semaphore-protocol/identity&quot;</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserIdentityCommitment</span>(<span class="hljs-params">userEmail: string</span>): string {
  <span class="hljs-keyword">const</span> hash = crypto.<span class="hljs-title function_">createHash</span>(<span class="hljs-string">&#x27;sha256&#x27;</span>);
  
  <span class="hljs-keyword">const</span> <span class="hljs-attr">length</span>:number = <span class="hljs-number">32</span>;
  <span class="hljs-keyword">const</span> seed = userEmail + process.<span class="hljs-property">env</span>.<span class="hljs-property">SECRET_KEY</span>;
  hash.<span class="hljs-title function_">update</span>(seed);
  <span class="hljs-keyword">const</span> buffer = crypto.<span class="hljs-title function_">randomBytes</span>(length);
  <span class="hljs-keyword">const</span> charCodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(length);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
    <span class="hljs-keyword">const</span> hashByte = hash.<span class="hljs-title function_">digest</span>()[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">const</span> combinedByte = hashByte ^ buffer[i];
    <span class="hljs-keyword">const</span> charCode = <span class="hljs-number">32</span> + (combinedByte % <span class="hljs-number">95</span>);
    charCodes[i] = charCode;
    hash.<span class="hljs-title function_">update</span>(<span class="hljs-title class_">String</span>.<span class="hljs-title function_">fromCharCode</span>(charCode));
  }
  <span class="hljs-keyword">const</span> hashStr = <span class="hljs-title class_">String</span>.<span class="hljs-title function_">fromCharCode</span>(...charCodes);
  <span class="hljs-keyword">const</span> identity = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Identity</span>(hasStr)
	<span class="hljs-keyword">return</span> {<span class="hljs-string">&quot;identityCommitment&quot;</span>:identity.<span class="hljs-property">commitment</span>};
}
</code></pre>
<pre><code class="language-tsx"><span class="hljs-comment">// Get the identity commitment on the client</span>
<span class="hljs-keyword">let</span> identityCommitment;
<span class="hljs-title function_">getUserIdentityCommitment</span>(session.<span class="hljs-property">user</span>.<span class="hljs-property">email</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {
       identityCommitment = data.<span class="hljs-property">identityCommitment</span>;
 }).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
       <span class="hljs-title function_">setError</span>(<span class="hljs-string">&quot;Something went wrong!&quot;</span>);
       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;[VOTE_MODAL]: &#x27;</span>, error);
});
</code></pre>
</li>
<li>
<p>ZK Proofs are generated which can prove that user is approved by the election admin and is the same user who created the proof.</p>
<pre><code class="language-tsx"><span class="hljs-keyword">import</span> { generateProof } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@semaphore-protocol/proof&quot;</span>;

<span class="hljs-keyword">const</span> { proof, merkleTreeRoot, nullifierHash } = <span class="hljs-keyword">await</span> <span class="hljs-title function_">generateProof</span>(
         identity,
         group,
         electionId.<span class="hljs-title function_">toNumber</span>(),
         vote
 );
</code></pre>
</li>
<li>
<p>The ZK Proofs along with the user vote, are then passed to the backend, from where they are then submitted to the blockchain, to be verified and then their vote is registered.</p>
  <aside>
  ðŸ’¡ External nullifier is used to prevent user from voting twice in the same election.
  </aside>
<pre><code class="language-tsx"><span class="hljs-keyword">let</span> response;
response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;api/vote&quot;</span>, {
        <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;POST&quot;</span>,
        <span class="hljs-attr">headers</span>: { <span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;application/json&quot;</span> },
        <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({
              vote,
              merkleTreeRoot,
              nullifierHash,
              proof,
              <span class="hljs-comment">// This will work as external nullifier.</span>
              electionId
	      })
 })
</code></pre>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>
<p>1.3.3 Backend Implementation</p>
<ul>
<li>
<p>1.3.3.1: Setup database with Prisma as ORM.</p>
<ul>
<li>
<p>Database design: The database schema consists of four main tables: Users, Elections, Candidates, and Voter_Registrations.</p>
<ul>
<li>The Users table stores information about all of our application's users, it includes their unique user_id, email, user_type (normal or election_creator), and wallet_address. The user_type field differentiates between regular users who can register to vote and users who can create elections. The wallet_address is used to connect the user's web3 wallet for creating elections.</li>
<li>The Elections table contains details about each election, such as its unique election_id, creator_id (referencing the Users table), contract_address of the associated smart contract, title, description,type, start_time, end_time, status, subscribed users and the election result.</li>
<li>The Candidates table stores information about the candidates for each election. It includes a unique candidate_id, the election_id it belongs to (referencing the Elections table), the candidate's name, additional information, a photo_url.</li>
<li>The Voter_Registrations table manages the voter registration process. It contains a unique registration_id, the election_id (referencing the Elections table), the user_id of the voter (referencing the Users table), and the status of their registration (pending, approved, or rejected.</li>
</ul>
</li>
<li>
<p>Setting up Prisma as ORM:</p>
<p>Autogenerated <code>prisma/**schema.prisma</code> file:**</p>
<pre><code class="language-tsx">datasource db {
  provider = <span class="hljs-string">&quot;postgresql&quot;</span>
  url      = <span class="hljs-title function_">env</span>(<span class="hljs-string">&quot;DATABASE_URL&quot;</span>)
}

generator client {
  provider = <span class="hljs-string">&quot;prisma-client-js&quot;</span>
}

model <span class="hljs-title class_">User</span> {
  user_id        <span class="hljs-title class_">String</span>            @id @<span class="hljs-title function_">default</span>(<span class="hljs-title function_">cuid</span>())
  email          <span class="hljs-title class_">String</span>            @unique
  user_type      <span class="hljs-title class_">String</span>
  wallet_address <span class="hljs-title class_">String</span>?
  registrations  <span class="hljs-title class_">Voter</span>_Registration[]
}

model <span class="hljs-title class_">Election</span> {
  election_id      <span class="hljs-title class_">String</span>        @id @<span class="hljs-title function_">default</span>(<span class="hljs-title function_">cuid</span>())
  creator_id       <span class="hljs-title class_">String</span>
  contract_address <span class="hljs-title class_">String</span>
  title            <span class="hljs-title class_">String</span>
  description      <span class="hljs-title class_">String</span>
  electionType     <span class="hljs-title class_">String</span>
  start_time       <span class="hljs-title class_">DateTime</span>
  end_time         <span class="hljs-title class_">DateTime</span>
  status           <span class="hljs-title class_">String</span>
  result           <span class="hljs-title class_">String</span>?  <span class="hljs-comment">// we will store candidate_id here.</span>
  candidates       <span class="hljs-title class_">Candidate</span>[]
  registrations    <span class="hljs-title class_">Voter</span>_Registration[]
  subscribed_users <span class="hljs-title class_">User</span>[]
  candidate  <span class="hljs-title class_">Candidate</span> @<span class="hljs-title function_">relation</span>(<span class="hljs-attr">fields</span>: [result],<span class="hljs-attr">references</span>: [candidate_id]
}

model <span class="hljs-title class_">Candidate</span> {
  candidate_id <span class="hljs-title class_">String</span>       @id @<span class="hljs-title function_">default</span>(<span class="hljs-title function_">cuid</span>())
  election_id  <span class="hljs-title class_">String</span>
  name         <span class="hljs-title class_">String</span>
  info         <span class="hljs-title class_">String</span>?
  photo_url    <span class="hljs-title class_">String</span>?
  election     <span class="hljs-title class_">Elections</span> @<span class="hljs-title function_">relation</span>(<span class="hljs-attr">fields</span>: [election_id], <span class="hljs-attr">references</span>: [election_id])
}

model <span class="hljs-title class_">Voter</span>_Registration {
  registration_id <span class="hljs-title class_">String</span>       @id @<span class="hljs-title function_">default</span>(<span class="hljs-title function_">cuid</span>())
  election_id     <span class="hljs-title class_">String</span>
  user_id         <span class="hljs-title class_">String</span>
  status          <span class="hljs-title class_">String</span>
  election        <span class="hljs-title class_">Elections</span> @<span class="hljs-title function_">relation</span>(<span class="hljs-attr">fields</span>: [election_id], <span class="hljs-attr">references</span>: [election_id])
  user            <span class="hljs-title class_">Users</span>     @<span class="hljs-title function_">relation</span>(<span class="hljs-attr">fields</span>: [user_id], <span class="hljs-attr">references</span>: [user_id])
}

<span class="hljs-comment">// ############ Tables below are required for next auth ###############</span>
model <span class="hljs-title class_">Account</span> {
  id                <span class="hljs-title class_">String</span>  @id @<span class="hljs-title function_">default</span>(<span class="hljs-title function_">cuid</span>())
  userId            <span class="hljs-title class_">String</span>
  type              <span class="hljs-title class_">String</span>
  provider          <span class="hljs-title class_">String</span>
  providerAccountId <span class="hljs-title class_">String</span>
  refresh_token     <span class="hljs-title class_">String</span>? @db.<span class="hljs-property">Text</span>
  access_token      <span class="hljs-title class_">String</span>? @db.<span class="hljs-property">Text</span>
  expires_at        <span class="hljs-title class_">Int</span>?
  token_type        <span class="hljs-title class_">String</span>?
  scope             <span class="hljs-title class_">String</span>?
  id_token          <span class="hljs-title class_">String</span>? @db.<span class="hljs-property">Text</span>
  session_state     <span class="hljs-title class_">String</span>?

  user <span class="hljs-title class_">User</span> @<span class="hljs-title function_">relation</span>(<span class="hljs-attr">fields</span>: [userId], <span class="hljs-attr">references</span>: [user_id], <span class="hljs-attr">onDelete</span>: <span class="hljs-title class_">Cascade</span>)
}

model <span class="hljs-title class_">VerificationToken</span> {
  id      <span class="hljs-title class_">String</span>   @id @<span class="hljs-title function_">default</span>(<span class="hljs-title function_">cuid</span>())
  email   <span class="hljs-title class_">String</span>
  token   <span class="hljs-title class_">String</span>   @unique
  expires <span class="hljs-title class_">DateTime</span>

  @@<span class="hljs-title function_">unique</span>([email, token])
}
</code></pre>
<p>To set up Prisma client we need to create new file <code>lib/prisma.ts</code> as follows:</p>
<pre><code class="language-tsx"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">PrismaClient</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@prisma/client&#x27;</span>;

<span class="hljs-keyword">const</span> globalForPrisma = <span class="hljs-variable language_">global</span> <span class="hljs-keyword">as</span> unknown <span class="hljs-keyword">as</span> { <span class="hljs-attr">prisma</span>: <span class="hljs-title class_">PrismaClient</span> };

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> prisma =
  globalForPrisma.<span class="hljs-property">prisma</span> ||
  <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrismaClient</span>({
    <span class="hljs-attr">log</span>: [<span class="hljs-string">&#x27;query&#x27;</span>],
  });

<span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span>) globalForPrisma.<span class="hljs-property">prisma</span> = prisma;
</code></pre>
<p>This will allow us to easily query the database from our API routes and server components when needed.</p>
</li>
</ul>
</li>
<li>
<p>1.3.3.2: Setup NextAuth.Js</p>
<p>As we provide our users with two options to login/register:</p>
<ol>
<li>Sign In with Google</li>
<li>Email and Password</li>
</ol>
<ul>
<li>
<p>We will have to create two files in the root of our project</p>
<ol>
<li>
<p>auth.config.ts</p>
<pre><code class="language-tsx"><span class="hljs-comment">// We have this file so that we can use edge, even though prisma doesn&#x27;t works with edge.</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Credentials</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;next-auth/providers/credentials&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Google</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;next-auth/providers/google&quot;</span>;

<span class="hljs-keyword">import</span> type { <span class="hljs-title class_">NextAuthConfig</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;next-auth&quot;</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">LoginSchema</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./form-schema&quot;</span>;
<span class="hljs-keyword">import</span> { getUserByEmail } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./utils/user&quot;</span>;
<span class="hljs-keyword">import</span> bcrypt <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;bcryptjs&quot;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    <span class="hljs-attr">providers</span>: [
        <span class="hljs-title class_">Google</span>({
            <span class="hljs-attr">clientId</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">GOOGLE_CLIENT_ID</span>,
            <span class="hljs-attr">clientSecret</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">GOOGLE_CLIENT_SECRET</span>,
        }),
        <span class="hljs-title class_">Credentials</span>({
            <span class="hljs-keyword">async</span> <span class="hljs-title function_">authorize</span>(<span class="hljs-params">credentials</span>) {

                <span class="hljs-keyword">const</span> validatedFields = <span class="hljs-title class_">LoginSchema</span>.<span class="hljs-title function_">safeParse</span>(credentials);

                <span class="hljs-keyword">if</span> (validatedFields.<span class="hljs-property">success</span>) {
                    <span class="hljs-keyword">const</span> { email, password } = validatedFields.<span class="hljs-property">data</span>;

                    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getUserByEmail</span>(email);
                    <span class="hljs-keyword">if</span> (!user || !user.<span class="hljs-property">password</span>) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
                    }

                    <span class="hljs-keyword">const</span> isPasswordCorrect = <span class="hljs-keyword">await</span> bcrypt.<span class="hljs-title function_">compare</span>(
                        password,
                        user.<span class="hljs-property">password</span>
                    );

                    <span class="hljs-keyword">if</span> (isPasswordCorrect) {
                        <span class="hljs-keyword">return</span> user;
                    }
                }
                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            }
        })
    ],
} satisfies <span class="hljs-title class_">NextAuthConfig</span>;
</code></pre>
</li>
<li>
<p>auth.ts</p>
<pre><code class="language-tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">NextAuth</span>, { type <span class="hljs-title class_">DefaultSession</span>, type <span class="hljs-title class_">User</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;next-auth&quot;</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">PrismaAdapter</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@auth/prisma-adapter&quot;</span>;
<span class="hljs-keyword">import</span> { db } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./lib/db&quot;</span>;
<span class="hljs-keyword">import</span> authConfig <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./auth.config&quot;</span>;
<span class="hljs-keyword">import</span> { getUserById } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./utils/user&quot;</span>;
<span class="hljs-keyword">import</span> { getTwoFactorConfirmationByUserId } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./utils/two-factor-confirmation&quot;</span>;
<span class="hljs-keyword">import</span> { getAccountByUserId } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./actions/account&quot;</span>;

<span class="hljs-keyword">export</span> type <span class="hljs-title class_">ExtendedUser</span> = <span class="hljs-title class_">DefaultSession</span>[<span class="hljs-string">&quot;user&quot;</span>] &amp; {
    <span class="hljs-attr">role</span>: string;
    <span class="hljs-attr">isOAuth</span>: boolean;
}

declare <span class="hljs-variable language_">module</span> <span class="hljs-string">&quot;next-auth&quot;</span> {
    interface <span class="hljs-title class_">Session</span> {
        <span class="hljs-attr">user</span>: <span class="hljs-title class_">ExtendedUser</span>;
    }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> {
    <span class="hljs-attr">handlers</span>: { <span class="hljs-variable constant_">GET</span>, <span class="hljs-variable constant_">POST</span> },
    auth,
    signIn,
    signOut
} = <span class="hljs-title class_">NextAuth</span>({
    <span class="hljs-comment">// So that it automatically marks email verified on OAuth</span>
    <span class="hljs-attr">pages</span>: {
        <span class="hljs-attr">signIn</span>: <span class="hljs-string">&quot;/auth/login&quot;</span>,
        <span class="hljs-attr">error</span>: <span class="hljs-string">&quot;/auth/error&quot;</span>
    },
    <span class="hljs-attr">events</span>: {
        <span class="hljs-keyword">async</span> <span class="hljs-title function_">linkAccount</span>(<span class="hljs-params">{ user }</span>) {
            <span class="hljs-keyword">await</span> db.<span class="hljs-property">user</span>.<span class="hljs-title function_">update</span>({
                <span class="hljs-attr">where</span>: {
                    <span class="hljs-attr">id</span>: user.<span class="hljs-property">id</span>,
                },
                <span class="hljs-attr">data</span>: {
                    <span class="hljs-attr">emailVerified</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(),
                }
            })
        }
    },
    <span class="hljs-attr">callbacks</span>: {
        <span class="hljs-keyword">async</span> <span class="hljs-title function_">signIn</span>(<span class="hljs-params">{ user, account }</span>) {

            <span class="hljs-keyword">if</span> (account?.<span class="hljs-property">provider</span> !== <span class="hljs-string">&quot;credentials&quot;</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }

            <span class="hljs-keyword">if</span> (!user.<span class="hljs-property">id</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
            <span class="hljs-keyword">const</span> existingUser = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getUserById</span>(user.<span class="hljs-property">id</span>);

            <span class="hljs-keyword">if</span> (!existingUser || !existingUser.<span class="hljs-property">emailVerified</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }

            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        },
        <span class="hljs-keyword">async</span> <span class="hljs-title function_">session</span>(<span class="hljs-params">{ token, session }</span>) {
            <span class="hljs-keyword">if</span> (token?.<span class="hljs-property">sub</span> &amp;&amp; session?.<span class="hljs-property">user</span>) {
                session.<span class="hljs-property">user</span>.<span class="hljs-property">id</span> = token.<span class="hljs-property">sub</span>;
            }
            <span class="hljs-keyword">if</span> (token?.<span class="hljs-property">role</span> &amp;&amp; session?.<span class="hljs-property">user</span>) {
                session.<span class="hljs-property">user</span>.<span class="hljs-property">role</span> = token.<span class="hljs-property">role</span>;
            }
            <span class="hljs-keyword">if</span> (session?.<span class="hljs-property">user</span>) {
                session.<span class="hljs-property">user</span>.<span class="hljs-property">email</span> = token.<span class="hljs-property">email</span>;
                session.<span class="hljs-property">user</span>.<span class="hljs-property">isOAuth</span> = token.<span class="hljs-property">isOAuth</span>;
            }
            <span class="hljs-keyword">return</span> session;
        },
        <span class="hljs-keyword">async</span> <span class="hljs-title function_">jwt</span>(<span class="hljs-params">{ token }</span>) {
            <span class="hljs-keyword">if</span> (!token.<span class="hljs-property">sub</span>) {
                <span class="hljs-keyword">return</span> token;
            }
            <span class="hljs-keyword">const</span> existingUser = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getUserById</span>(token.<span class="hljs-property">sub</span>);
            <span class="hljs-keyword">if</span> (!existingUser) {
                <span class="hljs-keyword">return</span> token;
            }
            <span class="hljs-keyword">const</span> existingAccount = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getAccountByUserId</span>(existingUser.<span class="hljs-property">id</span>);
            token.<span class="hljs-property">isOAuth</span> = !!existingAccount;
            token.<span class="hljs-property">email</span> = existingUser.<span class="hljs-property">email</span>;
            <span class="hljs-keyword">return</span> token;
        }
    },
    <span class="hljs-attr">adapter</span>: <span class="hljs-title class_">PrismaAdapter</span>(db),
    <span class="hljs-attr">session</span>: { <span class="hljs-attr">strategy</span>: <span class="hljs-string">&quot;jwt&quot;</span> },
    ...authConfig
});
</code></pre>
</li>
</ol>
</li>
<li>
<p>Then in <code>app/api</code> directory of the client folder add a route group <code>auth/[...nextauth]/route.ts</code></p>
<pre><code class="language-tsx"><span class="hljs-keyword">export</span> { <span class="hljs-variable constant_">GET</span>, <span class="hljs-variable constant_">POST</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/auth&quot;</span>;
</code></pre>
<p>This route will catch all authentication related requests.</p>
</li>
<li>
<p>After this we will create server actions for <code>login</code> , <code>register</code> and <code>verify-email</code> that will be used from the corresponding pages on the client.</p>
</li>
</ul>
</li>
<li>
<p>1.3.3.3: Handle user related routes</p>
<ul>
<li>
<p>Route to send proofs to the blockchain: <code>api/vote</code></p>
<pre><code class="language-tsx"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">NextResponse</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;next/server&quot;</span>;

<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PRIVATE_KEY</span> = process.<span class="hljs-property">env</span>.<span class="hljs-property">PRIVATE_KEY</span>;
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">ALCHEMY_API_KEY</span> = process.<span class="hljs-property">env</span>.<span class="hljs-property">ALCHEMY_API_KEY</span>;
<span class="hljs-keyword">const</span> contractAddress = process.<span class="hljs-property">env</span>.<span class="hljs-property">ONEVOTE_ADDRESS</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">POST</span>(<span class="hljs-params">req:Request</span>){
    <span class="hljs-keyword">try</span>{
		 <span class="hljs-keyword">const</span> { vote, merkleTreeRoot, nullifierHash, proof,electionId} = req.<span class="hljs-title function_">json</span>();  
	    
     <span class="hljs-keyword">const</span> provider = <span class="hljs-keyword">new</span> providers.<span class="hljs-title class_">AlchemyProvider</span>(<span class="hljs-variable constant_">ALCHEMY_API_KEY</span>);
	   <span class="hljs-keyword">const</span> signer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Wallet</span>(<span class="hljs-variable constant_">PRIVATE_KEY</span>,provider);
	   <span class="hljs-keyword">const</span> contract = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Contract</span>(contractAddress,oneVote.<span class="hljs-property">abi</span>,signer);
		  
     <span class="hljs-keyword">const</span> transaction = <span class="hljs-keyword">await</span> contract.<span class="hljs-title function_">vote</span>(vote,nullifierHash,electionId,merkleTreeRoot,proof);
	   <span class="hljs-keyword">await</span> transaction.<span class="hljs-title function_">wait</span>();
	   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NextResponse</span>(<span class="hljs-string">&quot;Success&quot;</span>,{<span class="hljs-attr">status</span>:<span class="hljs-number">200</span>})
	     
    }<span class="hljs-keyword">catch</span>(error){
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;[ERROR_WHILE_SUBMITTING_VOTE_TO_BLOCKCHAIN]: &#x27;</span>,error);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NextResponse</span>(<span class="hljs-string">&quot;Server Error&quot;</span>,{<span class="hljs-attr">status</span>:<span class="hljs-number">500</span>})
    }
}
</code></pre>
</li>
<li>
<p>Similarly we can create the following routes:</p>
<ul>
<li>Route to add connect a wallet to user account <code>api/user/add-wallet</code></li>
<li>Route to add election: <code>api/election/new</code></li>
<li>Route to add candidate to the election: <code>api/election/[electionId]/add-candidate</code></li>
<li>Route to register as a voter to the election: <code>api/election/[electionId]/register</code></li>
<li>Route to subscribe  to get results of the election when declared  <code>api/elections/[electionId]/notify</code></li>
<li>Route to approve a voter for election: <code>api/elections/[electionId]/approve</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>1.3.4 Smart Contract Interactions</p>
<p>On the smart contract we will need to:</p>
  <aside>
  ðŸ’¡ For sake of **explanation** we are considering OneVote.sol as an entry point contract and  VotingProcess.sol as the election contract, after integration with all the other election contracts which are implemented with diamond proxy, the functions we are modify will change.
  </aside>
  <aside>
  ðŸ’¡ We are using contracts provided with semaphore SDK: these are set of opensource utility smart contracts, which are well audited making them appropriately **reliable**.
  </aside>
<ol>
<li>
<p>Add a state variable to hold the address of our semaphore smart contract.</p>
<pre><code class="language-tsx"><span class="hljs-title class_">ISemaphore</span> public immutable semaphore;
</code></pre>
</li>
<li>
<p>Modify the constructor to save Semaphore contract address on deployment.</p>
<pre><code class="language-tsx"><span class="hljs-title function_">constructor</span>(<span class="hljs-params">ISemaphore _semaphore</span>) {
        semaphore = <span class="hljs-title class_">ISemaphore</span>(_semaphore);          
  }
</code></pre>
</li>
<li>
<p>Create election: while creating the election proxy contract, we will create new semaphore group on-chain.</p>
<pre><code class="language-tsx"> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createVotingProcess</span>(<span class="hljs-params">
        string memory _name,
        string memory _description,
        uint _startDate,
        uint _endDate,
        uint256 _groupId
    </span>) public {
        address _votingProcessAdmin = msg.<span class="hljs-property">sender</span>;
        processCounter += <span class="hljs-number">1</span>;
        <span class="hljs-title class_">VotingProcess</span> vp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VotingProcess</span>(
            processCounter,
            _name,
            _description,
            _startDate,
            _endDate
        );
        votingProcesses[processCounter] = vp;
        votingProcessAdmins[vp] = _votingProcessAdmin;
        semaphore.<span class="hljs-title function_">createGroup</span>(_groupId, <span class="hljs-number">32</span>, <span class="hljs-title function_">address</span>(msg.<span class="hljs-property">sender</span>));
    }
</code></pre>
</li>
<li>
<p>Add voter to election: we have to add the identity commitment of all the voters approved by the election admin.</p>
<pre><code class="language-tsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">addVoter</span>(<span class="hljs-params">uint256 identityCommitment</span>) public {
        semaphore.<span class="hljs-title function_">addMember</span>(groupId, identityCommitment);
        userAuthStatus[identityCommitment] = <span class="hljs-literal">true</span>;
}
</code></pre>
</li>
<li>
<p>Vote: This will have to be changed in order to first validate the ZK Proofs and only register the vote if the proof in valid.</p>
<pre><code class="language-tsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">vote</span>(<span class="hljs-params">
        uint256 _vote, <span class="hljs-comment">// candidate id.</span>
        uint256 nullifierHash,
        uint256 pollId,
        uint256 merkleTreeRoot,
        uint256[<span class="hljs-number">8</span>] calldata proof
    </span>) public {
        semaphore.<span class="hljs-title function_">verifyProof</span>(
            groupId,
            merkleTreeRoot,
            _vote,
            nullifierHash,
            pollId,
            proof
        );
        votingProcesses[pollId].<span class="hljs-title function_">vote</span>(_vote);
    }

</code></pre>
</li>
</ol>
</li>
</ul>
</li>
<li>
<p><strong>1.4 Thought Process and Design Decisions:</strong></p>
<ul>
<li>
<p>Why do we need a backend when all the data can be directly stored and fetched from the blockchain?</p>
<p>We need a backend because we cannot rely on the blockchain to fetch all the information needed to render our UI efficiently. By maintaining a database to store necessary information, we can efficiently implement logic to protect routes on the frontend and handle user authentication using email addresses. This way, we do not need to fetch the user authentication status for every single user.</p>
<p>Maintaining a separate backend also allows us to abstract the blockchain wherever necessary, resulting in a more native experience for a large portion of internet users who are not familiar with web3.</p>
</li>
<li>
<p>Why not directly submit proofs from the client to the blockchain?</p>
<ol>
<li>Blockchain abstraction: If we send the proofs directly to the blockchain, it will require users to have a wallet and interact with the blockchain. This user experience will alienate many potential users who are not familiar with blockchain technology.</li>
<li>User anonymity is compromised: Even if we choose to make connecting a wallet necessary for voters and have them make the vote call from the client, the transaction can still be linked to their wallet address, which is exactly what we are trying to avoid with our anonymous voting flow. Using the backend as a middle layer to send proofs, we use a common private key to send proofs for all users. This way, the transaction will only be linked to the common wallet and not the user, resulting in true user anonymity.</li>
</ol>
</li>
<li>
<p>Why did I choose to exclude user KYC and have the election admin approve users manually?</p>
<ol>
<li>The scope of our application should initially be small organizations, communities, etc. Here, the verification requirements can vary greatly for different types of users, and this cannot be anyways covered by basic KYC all the time.</li>
<li>If we consider implementing KYC we should keep it separate from our Agora Blockchain application to avoid doing multiple things in one repository and to keep reusability in mind.</li>
<li>For automation of voter approval, we can later provide a single API to election admins, using which they could add checks and have all applications processed automatically using defined rules. Developing this is a significant task, so I put it out of scope to focus on implementing a good base first, but we can surely add it to the TODO list for our project.</li>
</ol>
</li>
<li>
<p>How are transaction costs for making a vote call compensated?</p>
<p>I have given it some thought, and I believe the cost of conducting an election should be borne by the election organizer. We can make them pay while making the createElection call itself by adding one extra require statement inside the createElection function.</p>
<pre><code class="language-solidity">require(msg.value&gt;=/*The cost for conducting the election*/,&quot;Please send ETH to cover the cost of conducting the election);
</code></pre>
<p>However, I did not specifically mention it because, during development, we are using test tokens anyway. We can later discuss the cost with the mentor and organization admin and add that functionality accordingly.</p>
</li>
</ul>
</li>
</ul>
<h2 id="2-election-subscription-and-voter-notifications">2. Election Subscription and Voter Notifications</h2>
<ul>
<li>
<p>2.1 <strong>Motivation and Goals</strong></p>
<p>Keeping users informed throughout the election process is important factor for good user experience. By introducing an election subscription and notification system, voters can stay updated on the status of elections they are interested in, receiving timely notifications when results are available. This feature aims to improve the overall user experience and increase participation by keeping them informed without the need for constant manual checking.</p>
<p>The primary goals of this feature are:</p>
<ul>
<li>Allow voters to subscribe to elections of their choice.</li>
<li>Notify subscribed voters when election results are calculated and available.</li>
</ul>
</li>
<li>
<p>2.2  <strong>Flow</strong></p>
<ol>
<li>
<p><strong>Election Creation</strong>: When an election is created, the election details including the end date/time are stored in the database.</p>
</li>
<li>
<p><strong>Subscription</strong>: Voters can subscribe to elections they are interested in through the UI.</p>
</li>
<li>
<p><strong>Cron Job</strong>: A single cron job is set up to run at a frequent interval, such as every minute. This cron job does the following:</p>
<ol>
<li>Queries the database to check for any elections that have ended but have not had their results calculated yet.</li>
<li>For each ended election found:
<ul>
<li>Calls theÂ <strong><code>calculateResult</code></strong>Â function on the smart contract to calculate the results.</li>
<li>Updates the election status and results in the database.</li>
<li>Retrieves the list of subscribed voters for that election from the database.</li>
<li>Sends email notifications to the subscribed voters using nodemailer, informing them that the election has ended and the results are available.</li>
</ul>
</li>
</ol>
</li>
<li>
<p><strong>View Results</strong>:  Users can view the election results by clicking on a link in the email notification, which takes them to the election page showing the results and stats.</p>
<p><img src="file:////workspaces/GSoC-2024/assets/notification_flow_(1).png" alt="notification flow (1).png"></p>
</li>
</ol>
</li>
<li>
<p>2.3 Technical Implementation</p>
<ul>
<li>
<p>2.3.1 Backend Subscription Management</p>
<ul>
<li>
<p>Create a <code>vercel.json</code>  at the root of client</p>
<pre><code class="language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">&quot;crons&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">&quot;path&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/api/cron&quot;</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">&quot;schedule&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;* */10 * * *&quot;</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
</li>
<li>
<p>Create a new files <code>emails.ts</code> here we will have to setup nodemailer related config</p>
<ol>
<li>
<p>Setup transporter</p>
<pre><code class="language-tsx"><span class="hljs-keyword">import</span> nodemailer <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;nodemailer&quot;</span>;

<span class="hljs-keyword">const</span> transporter = nodemailer.<span class="hljs-title function_">createTransport</span>({
  <span class="hljs-attr">service</span>: <span class="hljs-string">&#x27;gmail&#x27;</span>,
  <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;stmp.gmail.com&#x27;</span>,
  <span class="hljs-attr">port</span>: <span class="hljs-number">587</span>,
  <span class="hljs-attr">secure</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">auth</span>: {
    <span class="hljs-attr">user</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">SENDER_EMAIL</span>,
    <span class="hljs-attr">pass</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">SENDER_EMAIL_PASSWORD</span>
  },
});

</code></pre>
</li>
<li>
<p>Create a function to send email</p>
<pre><code class="language-solidity">export async function sendMail(emailContent: EmailContent, sendTo: string[]) {
  if (process.env.SENDER_EMAIL) {
    const mailOptions = {
      from: {
        name: 'Agora Blockchain',
        address: process.env.SENDER_EMAIL as string,
      },
      to: sendTo,
      html: `&lt;h1&gt;Results for the election ${emailContent.electionName} are now available, click here ${emailContent.link}&lt;/h1&gt;`;
      subject: 'Results Declared'
    };

    transporter.sendMail(mailOptions, (err: any, info: any) =&gt; {
      if (err) {
        return console.log('[SEND_EMAIL]: Error encountered during sending the email: ', err);
      }
      console.log('[SEND_EMAIL]: Success ', info);
    })
  } else {
    console.log('[SEND_EMAIL]: Env key not set correctly.');
  }
}
</code></pre>
</li>
</ol>
</li>
<li>
<p>Query for all the elections whose duration has ended but the results have not yet been calculated.</p>
<pre><code class="language-tsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getAllPendingElections</span>(<span class="hljs-params"></span>){
	<span class="hljs-keyword">const</span> endedElections = <span class="hljs-keyword">await</span> prisma.<span class="hljs-property">election</span>.<span class="hljs-title function_">findMany</span>({
  <span class="hljs-attr">where</span>: {
    <span class="hljs-attr">end_time</span>: {
      <span class="hljs-attr">lt</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(), <span class="hljs-comment">// Filter elections whose end time is less than the current date/time</span>
    },
    <span class="hljs-attr">result</span>: <span class="hljs-literal">null</span>, <span class="hljs-comment">// Filter elections where the result is null (not calculated yet)</span>
  },
  <span class="hljs-attr">include</span>: {
    <span class="hljs-attr">subscribed_users</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// Include the subscribed users for each election</span>
  },
});
<span class="hljs-keyword">return</span> endedElections;
}
</code></pre>
</li>
<li>
<p>Create a function where using a for loop to call the smart contract to calculate results, update the election details on the database, fetch the subscribed voters and send them emails</p>
<pre><code class="language-tsx"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">processEndedElections</span>(<span class="hljs-params">endedElections: Election[]</span>) {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> election <span class="hljs-keyword">of</span> endedElections) {
    <span class="hljs-keyword">try</span> {
	    <span class="hljs-comment">// This will be a function which calls the smart contract</span>
      <span class="hljs-keyword">const</span> winningCandidateId = <span class="hljs-keyword">await</span> <span class="hljs-title function_">calculateElectionResults</span>(election.<span class="hljs-property">contract_address</span>);

      <span class="hljs-keyword">await</span> prisma.<span class="hljs-property">election</span>.<span class="hljs-title function_">update</span>({
        <span class="hljs-attr">where</span>: {
          <span class="hljs-attr">election_id</span>: election.<span class="hljs-property">election_id</span>,
        },
        <span class="hljs-attr">data</span>: {
          <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;COMPLETED&#x27;</span>,
          <span class="hljs-attr">result</span>: winningCandidateId,
        },
      });

      <span class="hljs-keyword">const</span> subscribedUsers = election.<span class="hljs-property">subscribed_users</span>;
      <span class="hljs-keyword">const</span> emailContent = {
		      <span class="hljs-attr">electionName</span>:election.<span class="hljs-property">title</span>
		      <span class="hljs-attr">link</span>: <span class="hljs-string">`https://agorablockchain.com/elections/<span class="hljs-subst">${election.id}</span>`</span>;
      }
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> user <span class="hljs-keyword">of</span> subscribedUsers) {
			      <span class="hljs-keyword">await</span> <span class="hljs-title function_">sendMail</span>(emailContent, user.<span class="hljs-property">email</span>);
      }
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Election <span class="hljs-subst">${election.election_id}</span> processed successfully.`</span>);
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`Error processing election <span class="hljs-subst">${election.election_id}</span>:`</span>, error);
    }
  }
}
</code></pre>
</li>
<li>
<p>Create a new API route <code>api/cron/route.ts</code></p>
<pre><code class="language-tsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">POST</span>(<span class="hljs-params"></span>) {
	<span class="hljs-keyword">const</span> pendingElections = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getAllPendingElections</span>();
	<span class="hljs-keyword">await</span> <span class="hljs-title function_">processEndedElections</span>(pendingElections);
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Response</span>.<span class="hljs-title function_">json</span>({ <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;Success&quot;</span> });
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>2.3.3 <strong>Frontend Subscription UI</strong></p>
<p><img src="file:////workspaces/GSoC-2024/assets/Screenshot_2024-03-25_165816.png" alt="Screenshot 2024-03-25 165816.png"></p>
<p>When the confirm button is clicked we will call the backend route <code>api/elections/[electionId]/notify</code> .</p>
</li>
</ul>
</li>
</ul>
<h2 id="3-code-refactoring">3. Code Refactoring</h2>
<ul>
<li>3.1 <strong>Motivation and Goals</strong></li>
<li>3.2 <strong>Current Codebase Structure</strong></li>
<li>3.3 <strong>Proposed Refactoring</strong>
<ul>
<li>3.3.1 Migration to Next.js/TypeScript (include code snippets comparing old and new)</li>
<li>3.3.2 Folder Structure Reorganization (include a tree diagram of new structure)</li>
<li>3.3.3 Updating Deprecated Client Libraries</li>
</ul>
</li>
<li>3.4 <strong>Thought Process and  Benefits of Refactoring</strong></li>
</ul>
<h2 id="4-integrating-anonymous-voting-with-multiple-algorithms">4. Integrating Anonymous Voting with Multiple Algorithms</h2>
<ul>
<li>4.1 Motivation and Goals</li>
<li>4.2 Current State of Anonymous Voting</li>
<li>4.3 Proposed Integration
<ul>
<li>4.3.1 Extending Smart Contracts (include code snippets)</li>
<li>4.3.2 Integrating with Diamond Multi-Facet Proxy (include a diagram)</li>
</ul>
</li>
<li>4.4 Smart Contract Testing
<ul>
<li>4.4.1 Unit Testing (include sample test cases)</li>
</ul>
</li>
</ul>
<h2 id="5-adding-new-election-types">5. Adding New Election Types</h2>
<ul>
<li>5.1 Motivation and Goals</li>
<li>5.2 Proposed New Election Types
<ul>
<li>5.2.1 Approval Voting
<ul>
<li>5.2.1.1 Algorithm Overview (include pseudocode)</li>
<li>5.2.1.2 Smart Contract Implementation</li>
<li>5.2.1.3 Frontend Integration</li>
</ul>
</li>
<li>5.2.2 Quadratic Voting
<ul>
<li>5.2.2.1 Algorithm Overview (include mathematical formulas)</li>
<li>5.2.2.2 Smart Contract Implementation</li>
<li>5.2.2.3 Frontend Integration</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="outcomes">Outcomes</h1>
<ul>
<li>1 Project Impact</li>
<li>2 Future Scope and Maintainability</li>
</ul>
<h3 id=""></h3>
<ul>
<li>
<p>2.4 Thought Process and Design Decision</p>
<p>Why use cron jobs?</p>
</li>
</ul>

            <script async src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
            
        </body>
        </html>